面向对象风格，用一个EchoSever继承TcpServer(抽象类),实现三个接口OnConnection,OnMessage,OnClose
基于对象风格,用一根EchoSever包含一个TcpServer(具体类)对象，在构造函数中用bind()来注册三个成员函数

#include 单纯是让编译器找到相关的声明不会报错

若a.cpp用到了lib.h声明的函数 关键是在链接阶段 也就是 “g++ 命令” 或者makefile文件中 要有链接 即将多个.o文件生成可执行文件
`g++ -std=c++11 -c BlockingQueue.h` 命令会生成.gch文件 是头文件的预编译文件 以后如果有include这个头文件就会使用这个编译好的.gch文件
但若头文件中内容有修改，需要重新编译生成新的.gch文件

## C++的强制类型转化
为什么不用C的强制类型转化
1. 没有从形式上体现转换功能和风险的不同。
2. 将多态基类指针转换成派生类指针时不检查安全性，即无法判断转换后的指针是否确实指向一个派生类对象。
3. 难以在程序中寻找到底什么地方进行了强制类型转换。

## static_cast
能用的：比较“自然”和低风险的转换 如整型和浮点型、字符型之间的互相转换。另外，如果对象所属的类重载了强制类型转换运算符 T（如 T是 int、int* 或其他类型名），则 static_cast 也能用来进行对象到 T 类型的转换。 
不能的：
不能用于在不同类型的指针之间互相转换，也不能用于整型和指针之间的互相转换，当然也不能用于不同类型的引用之间的转换。因为这些属于风险比较高的转换。
## reinterpret_cast
用于进行各种不同类型的指针之间、不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换，reinterpret_cast 转换时，执行的过程是逐个比特复制的操作。

## const_cast
const_cast 运算符仅用于进行去除 const 属性的转换，它也是四个强制类型转换运算符中唯一能够去除 const 属性的运算符。

## dynamic_cast （专门用于多态）
用 reinterpret_cast 可以将多态基类（包含虚函数的基类）的指针强制转换为派生类的指针，但是这种转换不检查安全性，即不检查转换后的指针是否确实指向一个派生类对象。
dynamic_cast专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 NULL 指针。

dynamic_cast 是通过“运行时类型检查”来保证安全性的。dynamic_cast **不能用于将非多态基类的指针或引用强制转换为派生类的指针或引用——这种转换没法保证安全性**，只好用 reinterpret_cast 来完成。

## sizeof()和sizeof关键字区别
sizeof作为关键字 不能用作类型名上 sizeof()可以


